{"ast":null,"code":"import { audioManager } from './audioUtils';\nclass NotificationQueue {\n  constructor(maxSize = 100) {\n    this.queue = void 0;\n    this.maxSize = void 0;\n    this.callbacks = void 0;\n    this.queue = [];\n    this.maxSize = maxSize;\n    this.callbacks = new Set();\n  }\n  subscribe(callback) {\n    this.callbacks.add(callback);\n    return () => {\n      this.callbacks.delete(callback);\n    };\n  }\n  notify(notification) {\n    this.callbacks.forEach(callback => callback(notification));\n  }\n  addPioneerNotification(title, message, category, confidence) {\n    // Calculate priority based on category and confidence\n    let priority = 1;\n\n    // Higher priority for high confidence signals\n    if (confidence >= 0.9) priority += 2;else if (confidence >= 0.7) priority += 1;\n\n    // Additional priority for certain categories\n    if (category === 'Protocol_Scout' || category === 'RWA_Innovation') {\n      priority += 1;\n    }\n    const notification = {\n      id: Date.now().toString(),\n      title,\n      message,\n      type: 'pioneer',\n      category,\n      confidence,\n      timestamp: Date.now(),\n      priority,\n      read: false\n    };\n    this.add(notification);\n\n    // Play appropriate sound based on category and confidence\n    audioManager.playPioneerNotification(category, confidence);\n  }\n  add(notification) {\n    // Add new notification\n    this.queue.push(notification);\n\n    // Sort by priority and timestamp\n    this.queue.sort((a, b) => {\n      if (a.priority !== b.priority) {\n        return b.priority - a.priority; // Higher priority first\n      }\n      return b.timestamp - a.timestamp; // Newer first within same priority\n    });\n\n    // Trim queue if it exceeds max size\n    if (this.queue.length > this.maxSize) {\n      const toRemove = this.queue.length - this.maxSize;\n      // Remove oldest, lowest priority items\n      this.queue.splice(-toRemove);\n    }\n\n    // Notify subscribers\n    this.notify(notification);\n  }\n  markAsRead(id) {\n    const notification = this.queue.find(n => n.id === id);\n    if (notification) {\n      notification.read = true;\n      this.notify(notification);\n    }\n  }\n  markAllAsRead() {\n    this.queue.forEach(notification => {\n      notification.read = true;\n    });\n    // Notify for each notification\n    this.queue.forEach(notification => this.notify(notification));\n  }\n  getUnreadCount() {\n    return this.queue.filter(n => !n.read).length;\n  }\n  getPioneerNotifications() {\n    return this.queue.filter(n => n.type === 'pioneer');\n  }\n  getNotificationsByCategory(category) {\n    return this.queue.filter(n => n.type === 'pioneer' && n.category === category);\n  }\n  clear() {\n    this.queue = [];\n    this.callbacks.clear();\n  }\n  getAll() {\n    return [...this.queue];\n  }\n}\nexport const notificationQueue = new NotificationQueue();","map":{"version":3,"names":["audioManager","NotificationQueue","constructor","maxSize","queue","callbacks","Set","subscribe","callback","add","delete","notify","notification","forEach","addPioneerNotification","title","message","category","confidence","priority","id","Date","now","toString","type","timestamp","read","playPioneerNotification","push","sort","a","b","length","toRemove","splice","markAsRead","find","n","markAllAsRead","getUnreadCount","filter","getPioneerNotifications","getNotificationsByCategory","clear","getAll","notificationQueue"],"sources":["/Users/toyguntez/Visual Studio /Whale-Watch-Predictive-on-chain-signals/frontend/src/utils/NotificationQueue.ts"],"sourcesContent":["import { audioManager } from './audioUtils';\nimport { PioneerCategory } from '../types';\n\ninterface NotificationItem {\n  id: string;\n  title: string;\n  message: string;\n  type: 'info' | 'success' | 'warning' | 'error' | 'pioneer';\n  category?: PioneerCategory;\n  confidence?: number;\n  timestamp: number;\n  priority: number;\n  read: boolean;\n}\n\nclass NotificationQueue {\n  private queue: NotificationItem[];\n  private maxSize: number;\n  private callbacks: Set<(notification: NotificationItem) => void>;\n\n  constructor(maxSize: number = 100) {\n    this.queue = [];\n    this.maxSize = maxSize;\n    this.callbacks = new Set();\n  }\n\n  public subscribe(callback: (notification: NotificationItem) => void) {\n    this.callbacks.add(callback);\n    return () => {\n      this.callbacks.delete(callback);\n    };\n  }\n\n  private notify(notification: NotificationItem) {\n    this.callbacks.forEach(callback => callback(notification));\n  }\n\n  public addPioneerNotification(\n    title: string,\n    message: string,\n    category: PioneerCategory,\n    confidence: number\n  ) {\n    // Calculate priority based on category and confidence\n    let priority = 1;\n    \n    // Higher priority for high confidence signals\n    if (confidence >= 0.9) priority += 2;\n    else if (confidence >= 0.7) priority += 1;\n\n    // Additional priority for certain categories\n    if (category === 'Protocol_Scout' || category === 'RWA_Innovation') {\n      priority += 1;\n    }\n\n    const notification: NotificationItem = {\n      id: Date.now().toString(),\n      title,\n      message,\n      type: 'pioneer',\n      category,\n      confidence,\n      timestamp: Date.now(),\n      priority,\n      read: false\n    };\n\n    this.add(notification);\n\n    // Play appropriate sound based on category and confidence\n    audioManager.playPioneerNotification(category, confidence);\n  }\n\n  public add(notification: NotificationItem) {\n    // Add new notification\n    this.queue.push(notification);\n\n    // Sort by priority and timestamp\n    this.queue.sort((a, b) => {\n      if (a.priority !== b.priority) {\n        return b.priority - a.priority; // Higher priority first\n      }\n      return b.timestamp - a.timestamp; // Newer first within same priority\n    });\n\n    // Trim queue if it exceeds max size\n    if (this.queue.length > this.maxSize) {\n      const toRemove = this.queue.length - this.maxSize;\n      // Remove oldest, lowest priority items\n      this.queue.splice(-toRemove);\n    }\n\n    // Notify subscribers\n    this.notify(notification);\n  }\n\n  public markAsRead(id: string) {\n    const notification = this.queue.find(n => n.id === id);\n    if (notification) {\n      notification.read = true;\n      this.notify(notification);\n    }\n  }\n\n  public markAllAsRead() {\n    this.queue.forEach(notification => {\n      notification.read = true;\n    });\n    // Notify for each notification\n    this.queue.forEach(notification => this.notify(notification));\n  }\n\n  public getUnreadCount() {\n    return this.queue.filter(n => !n.read).length;\n  }\n\n  public getPioneerNotifications() {\n    return this.queue.filter(n => n.type === 'pioneer');\n  }\n\n  public getNotificationsByCategory(category: PioneerCategory) {\n    return this.queue.filter(\n      n => n.type === 'pioneer' && n.category === category\n    );\n  }\n\n  public clear() {\n    this.queue = [];\n    this.callbacks.clear();\n  }\n\n  public getAll() {\n    return [...this.queue];\n  }\n}\n\nexport const notificationQueue = new NotificationQueue();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}